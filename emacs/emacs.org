Emacs 笔记

* Emacs的基本操作
  
  From: http://www.cnblogs.com/leohxj/archive/2012/02/20/2359427.html
  
  
** Emacs的命令按键

   Emacs中主要使用命令按钮如下
   
   C键：代表 Contorl 的意思, 用户来控制与语言无关的单位（字符, 行）。键盘上为 ctrl 键。
   
   M键：代表 Meta 的意思, 用来控制与语言定义的单位（如词, 句子, 段落）。键盘上一般为 Alt 键。
   
   Esc：单击一次相当于M – 。
   
   - ：在Emacs的命令中, 你经常会看到  -  这个符号, 它代表按住前面一个字符, 比如C – x  就表示按住Ctrl再按x。
  
   命令的取消：C – g ,或者 按2次Esc.

** Emacs文件的操作

   包括对文件的打开, 存储, 和退出。
   
   文件的打开：C-x C-f, 在当前窗口打开一个文件buffer.
   
   文件的保存： C-x C-s,对当前文件进行存盘。C-x  s  保存多个缓冲区。
   
   文件的另存为：C-x C-w.
   
   打开一个新的farme:C-x 5 2.
   
   退出Emacs:C-x C-c.
   
** Emacs缓冲区(buffer)
   
   前面提到过buffer这个东西, 其实可以理解为Emacs为你的每个文件开辟的另外一个空间, 
   在这个空间里, 你可以对文件随心所欲的编辑, 而不用担心影响原文件。Emacs会定时给你的 
   buffer文件进行auto save, 并在同文件目录下命名一个#文件名#的文件（存盘后自动消失）, 
   所以你也不用担心所编辑的东西会丢失。
   
   
   显示所有缓冲区:C-x C-b.
   
   选择一个name缓冲区：C-x b,输入在缓冲区中的文件名, 默认为上一个buffer.
   
   上一个缓冲区：C-x left.
   
   下一个缓冲区：C-x right.
   
** 光标的移动


   在编辑文本时对光标的控制
   
   上：C-p(previous).
   下：C-n(next).
   左：C-b(back).
   右：C-f(forward).
   
   移动到文件的开始处：M-<.
   移动到文件的结尾处：M->.
   光标跳转到x行：M-g g x RTN
   
   移动到行首：C-a.
   移动到行末：C-e(end).
   向前移动一个词：M-f.
   向后移动一个词：M-b.
   向前移动一个句子：M-a.
   向后移动一个句子：M-e.
   
   向下滚动一屏：C-v(view). 向上滚动一屏：M-v. 将当前行置于屏幕中间：
   C-l.  2次 C-l 置于屏幕首, 3次 C-l 置于屏幕末。

*** Jumping shortcut keys
    C-M-f     Move forward over a balanced expression
    C-M-b     Move backward over a balanced expression
    C-M-k     Kill balanced expression forward
    C-M-SPC   put the mark at the end of the sexp.
    C-M-n  Move forward over a parenthetical group 
    C-M-p  Move backward over a parenthetical group 
    ;; C-M key binding can also be done by --> ESC Control-key

Use C-M-right and C-M-left (respectively backward-sexp and forward-sexp) to go to the beginning or the end of the current expression. This works for parenthesis pairs but also for plain words.
   
** 文件的基本编辑
对文本的删除, 复制, 粘贴等。
删除光标前字符：         backspace
删除当前字符：           C-d(delete)
删除光标前的一个词：     M-backspace
删除光标后的一个词：     M-d
删除光标处到行末的字符： C-k(kill)
删除光标处到句末的字符： M-k
撤销：                   C-x u(undo)  或者 C-/ 再或者 C-_ 推荐使用第一种,方便
移除标记mark set:        C-@          即标记从光标处开始的字符。
移除：                   C-w          移除 mark set 处到现光标处的字符。
召回上一次移除文字：     C-y(yank)
召唤以前移除的文字：     M-y          注意, 在C-y使用之后使用。
复制：                   M-w          从上一次mark set处, 到现在光标处的字符。
粘贴：                   C-y
全选：                   C-x h
   
** Emacs 下的列编辑模式
1. 选择区域
和普通的emacs 操作一样用 C-@ 选择高亮一块区域，注意最后光标的停留位置和初始位置之间
必须是有列的差值的，简言之，起始光标位置和终止光标位置不在同一列后续可选操作

2. 后续可选操作
在这块区域插入空白的方格，用 C-x r o
删除这块区域用 C-x r d （这种删除掉之后不留空白）
删除区域       C-x r c (删掉之后原位置保留为空)
复制并删除这块区域用 C-x r k
粘贴刚才 C-x r k复制的区域用 C-x r y
用字符替换选中区域用 C-x r t

复杂操作：
C-x r r   copy-rectangle-to-register 将选定的矩形区域复制到某个寄存器
选中去区域后  C-x r r 将选中区域复制到寄存器， 在输入这组键后命令栏会等待你输入寄存器号，
这时随便输入一个数字即可，不过的记得它，因为待会儿粘贴的时候还得用到这个寄存器号。 
我刚开始就是被这个寄存器号搞得头晕，半天没弄明白是什么意思，现在理解这不过是对操作的区域做一个编号，
待会在操作时比如复制时可以根据这个号码选择之前操作的区域。
C-x r i 插入寄存器的内容，输入此键后再输入寄存器号可将寄存器中的内容插入到当前区域。

http://blog.sina.com.cn/s/blog_61107c450100kjqg.html

1.先mark矩形块
------------------------------------------------
2.列编辑命令
------------------------------------------------
按键功能
C-x r k          ;; 剪切矩形块
C-x r y          ;; 粘贴矩形块
C-x r o          ;; 插入矩形块
C-x r c          ;; 删除矩形块
C-x r d          ;; 删除矩形块，并后面的补齐空白区
C-x r t          ;; 填充矩形块
C-x C-x          ;; 交换mark点
C-x r o          ;;在选定的矩形区域插入空白
http://home.eeworld.com.cn/my/space-uid-93649-blogid-74390.html


示例:
abcde
abcde
abcde
abcde
abcde

目标: 将每行的第一个字符换为 ff
操作: 
1. 选中如下区域
abcde
abcde
abcde
abcde
a
2. C-x r t 输入 ff 回车(RET)

目标: 将每行的第二个字符换为 xx
操作:
1. 选中如下区域
 bcde
abcde
abcde
abcde
ab
2. C-x r t 输入 xx 回车(RET)
   
** 文本的搜索

   Emacs 可以向前, 向后搜索字符串, 搜索命令是渐进的（incremental）的,
   就是搜索与输入同步, 没输入一个字符, Emacs 就已经开始搜索了。
   
   向前搜索：C-r.
   
   向后搜索：C-s.
   
   注意：在搜索时候, 可以按C-s/r 查看下/上一处, C-g取消搜索, 回到初始
   搜索光标处; <Enter>结束搜索, 光标留在搜索结果上。

** 多窗口

   Emacs迷人之处很多, 能在一个屏幕上同时显示多个文件就是其中之一。
   
   添加窗口：C-x 2.新添加的窗口为当前文件。
   
   关闭当前窗口外窗口：C-x 1.
   
   滚动下方窗口（向下）：C-M-v
   
   滚动下方窗口（向上）：C-M-Shift-v.
   
   遍历窗口：C-x o.
   
   在新窗口中打开文件：C-x 4 C-f.

** 更多帮助（more help）

   Emacs提供的功能实在是太多了, 更多的内容可以在Help文档中查看。
   
   基本的用法是C-h.
   
   Help文档信息：C-h ?.
   
   命令的简要说明：C-h c .后面加所要查询的命令。如 C-h c <enter>C-p <enter>.
   
   命令的更多说明：C-h k.
   
   解释一个函数：C-h f.
   
   显示Emacs变量文档：C-h v.
   
   相关命令搜索：C-h a .后面输入一个关键词。Emacs会显示所有与之相关的命令。
   
   
   附加说明
   
   命令的重复：C-u 数字 命令。以所给数字为次数, 重复命令。
   
** features

*** Redo (Undo undo)


Short version: by undoing the undo. If you undo, and then do a non-editing command such as C-f, then the next undo will undo the undo, resulting in a redo.

Longer version:

You can think of undo as operating on a stack of operations. If you perform some command (even a navigation command such as C-f) after a sequence of undo operations, all the undos are pushed on to the operation stack. So the next undo undoes the last command. Suppose you do have an operation sequence that looks like this:

1. Insert "foo"
2. Insert "bar"
3. Insert "I love spam"

Now, you undo. It undoes the last action, resulting in the following list:

1. Insert "foo"
2. Insert "bar"

If you do something other than undo at this point - say, C-f, the operation stack looks like this:

1. Insert "foo"
2. Insert "bar"
3. Insert "I love spam"
4. Undo insert "I love spam"

Now, when you undo, the first thing that is undone is the undo. Resulting in your original stack (and document state):

1. Insert "foo"
2. Insert "bar"
3. Insert "I love spam"

If you do a modifying command to break the undo sequence, that command is added after the undo and is thus the first thing to be undone afterwards. Suppose you backspaced over "bar" instead of hitting C-f. Then you would have had

1. Insert "foo"
2. Insert "bar"
3. Insert "I love spam"
4. Undo insert "I love spam"
5. Delete "bar"

This adding/re-adding happens ad infinitum. It takes a little getting used to, but it really does give Emacs a highly flexible and powerful undo/redo mechanism.
http://stackoverflow.com/questions/3527142/how-do-you-redo-changes-after-undo-with-emacs
   
* Emacs与buffer

From: http://blog.163.com/wobutianl@126/blog/static/133584820129119167881/


** buffer 列表（键入C-x C-b时显示在一窗口中）


   Emacs会创建它自己的专用buffer。这些内部buffer的名字一般来说格式为
*buffer name* 。 *Help*, *scratch* 和 *Buffer List* 就是 Emacs 创建的
其中一些 buffer 。

   当你启动 Emacs 时, 它会建立两个 buffer：

*Messages* scratch*

   *Messages* buffer存储了Emacs收集自它启动时从minibuffer里显示的消息; 
 *scratch*是个临时的scratchpad（涂鸦板）, 以便你有地方输入东西。除非你
 *使用C-x C-w明确的把它写到文件中, 否则它不会被保存下来。

 当然, 一般来说你用Emacs编辑文件时, 这些文件就会被拷贝到同名的buffer中。
 如果你需要获得帮助, 则会进入 *Help* buffer。

 能在Emacs里打开的buffer数量实际上没有限制。大多数情况下, 只显示一个或
 两个buffer; 不过即使你无法看到全部, 你在某个Emacs会话里 创建的buffer
 仍处于活动状态。你可以把这些buffer想象成一叠纸, 只有放在最上面的那页
 才显示在你眼前。不过任何时候, 你都可以翻到另一页（另 一个buffer）, 或
 者也可以创建一个新页。

 每个buffer都关联一个主模式（major mode）, 它决定了Emacs在这个buffer里
 的行为。例如, 设计用来书写文本的文本模式（text mode）, 和Lisp模式的表
 现就不一样, 后者被设计用来编写Lisp程序。

** 如何操作多个 buffer


 如果要新建包含一个文件的buffer, 只需键入 C-x C-f 找到该文件。
 Emacs 就会自动新建一个buffer并定位到该buffer。
 如果该文件已打开, C-x C-f 只是
 定位到已有buffer中, 这一点很有意义, 可以避免同一文件存在多个buffer导
 致混乱。
 如果键入 C-x C-f 后输入的文件名不存在, Emacs认为你想新建一个
 文件, 并定位到一个空白buffer中。
 C-x b：在多个buffer之间进行切换; 键入命令后输入buffer名, 回车。
 如果已存在该buffer, 则切换到该buffer中; 否
 则以输入的 buffer名新建一个buffer, 但是注意这个buffer并没有和文件相关,
 因此关闭Emacs, 它不会给你任何提示。

 C-mouse 1：按住Ctrl并单击鼠标左键, 会弹出一个Buffer Menu, 它会按主模
 式类型列出活动的buffer供你选择。

 C-x ->(<-)：按下C-x后（放开）再按向右（左）方向键可以定位到下（上）一
 个buffer中。

 我的习惯是： c-x c-b 显示所有名字 c-x b 输入要切换的buffer名字。

** 如何删除 buffer


 注 意：如果你修改了一个buffer（且该buffer和一个文件相关）, 则Emacs会
 在删除buffer前询问你是否保存所做修改; 如果这个 buffer和文件不相关, 则
 你在该buffer里所做任何修改都会丢失, Emacs认为你不在乎这些buffer因此不
 作任何提示。因此编辑重要的 buffer之前最好先 C-x C-w 写到文件中, 或者
 用 C-x C-f 新建buffer。

 C-x k：kill-buffer命令, 删除一个buffer; 

 M-x kill-some-buffers：删除一些buffer; 

 如果删除了当前会话里的所有buffer, Emacs会新建一个 *scratch* buffer,
 总得有个东西显示在屏幕上不是？:P

** 如何保存 buffer
   
   C-x C-s：保存当前buffer; 
   
   C-x s：即save-some-buffers命令, 一次保存所有buffer; 
   
** 如何重命名 buffer
   
   M-x rename-buffer：重命名buffer; 
   
** 如何使 buffer 只读

   C-x C-q：切换buffer的read-only和read-write状态; 

** buffer和window的关系

   
   buffer和window并不是一一对应的, 同一个buffer可以有多个window, 比如你
   可以同时在多个window里查看同一buffer的不同部分。Mark是和buffer关联的; 
   而point是和window关联的。
   
   C-x 2：即split-window-vertically命令, 水平切分窗口; 
   
   C-x 3：垂直切分窗口; 
   
   C-x 4 b(f)：在另一个窗口选择另一个buffer（查找另一个文件）, 这样你可
   以不用切换到另一个window, 就改变其buffer或打开文件; 
   
   C-M-v：滚动另一个window（C-v是滚动当前window）; 
   
   C-x o：此处 o 表示other（其它）, 移动光标到另一个window; 
   
   C-x 0：删除当前所在的window; 
   
   C-x 1：删除当前所在window之外的所有window; 
   
   C-x 5 2：新建一个frame;   
   
** unsplit window 合并窗口
unsplit window as follows

+--------------+-------------+             +--------------+-------------+
|              |             |             |              |             |
|              |             |             |              |             |
|              |             |             |              |             |
+--------------+             |     -->     |              |             |
|              |             |             |              |             |
|              |             |             |              |             |
|              |             |             |              |             |
+--------------+-------------+             +--------------+-------------+



+--------------+--------------+            +-----------------------------+
|              |              |            |                             |
|              |              |            |                             |
|              |              |            |                             |
+--------------+--------------+    -->     +-----------------------------+
|                             |            |                             |
|                             |            |                             |
|                             |            |                             |
+-----------------------------+            +-----------------------------+

use the [C-x 0] key combination to delete the current window

use the [C-u C-x 0] key combination to delete another window
http://stackoverflow.com/questions/5360028/emacs-unsplit-a-particular-window-split

** swap buffer 交换窗口内容

*** buffer-move
C-S-up    : buf-move-up      move current buffer to it's upward window
C-S-down  : buf-move-down    move current buffer to it's downward window
C-S-left  : buf-move-left    move current buffer to it's left window
C-S-right : buf-move-right   move current buffer to it's right window

*** transpose-frame
transpose-frame             … Swap x-direction and y-direction
flip-frame                  … Flip vertically
flop-frame                  … Flop horizontally
rotate-frame                … Rotate 180 degrees
rotate-frame-clockwise      … Rotate 90 degrees clockwise
rotate-frame-anti-clockwise … Rotate 90 degrees anti-clockwise

http://stackoverflow.com/questions/1774832/how-to-swap-the-buffers-in-2-windows-emacs

* Emacs与文件

** emacs 产生的 *~ 和 #*# 文件
   
      文件名~：备份（backup）文件; 
   
      #文件名#：自动保存（autosave）文件。
   
   使用 emacs 编辑 head.c 时产生的 #head.c# 和 head~ 两个文件有什么区别？
   
      保存文件时, Emacs 里的文本将被拷贝到文件里。在你覆盖的时候, Emacs 把原始文件改为一个
   新名字以使它不至于丢失。新名字是在原来名字的后面加一个“~”。 
   
      Emacs 还有自动保存的功能, 当你改动了一个文件还未存盘的话, 所作的改动也许会由于系统崩溃
   而丢失。为防止这种情况发生, Emacs 在编辑时为每个文 件提供了“自动保存 (auto save)”。
   自动保存的文件的文件名前后都有一个 # 号。例如, 如果你编辑的文件名叫 “hello.c”, 
   自动保存的文件的文件名就叫 “#hello.c#”。当你正常的保存了文件后, Emacs会删除这个自动
   保存的文件。如果遇到死机, 打开文件（是你编辑的文件而不是自动保存的文件）后, 按
            M-x recover file <Return>
   来恢复你的编辑。当提示确认时, 输入
            yes <Return> 
   来继续恢复自动保存的数据。
   
* 设置主题
** 主题文件
  如, 设置了一个主题名为 bla-theme.el
使用方式默认安装时, 配置主题的 elisp 文件放置在如下位置
/usr/local/share/emacs/24.5/etc/themes

使用Windows方式安装时, 配置主题的 elisp 文件放置在如下位置
/usr/local/emacs-24.5/share/emacs/24.5/etc/themes/
** 字体设置
*** 字体设置为 DejaVu Sans Mono Book
DejaVu Sans Mono Book的好处是中文与英文高度相等,且宽度中文是英文的两倍.
用(set-frame-font "DejaVu Sans Mono Book-12")设置会提示 "Font not found"
$ fc-list |grep 'DejaVu Sans Mono'
/usr/share/fonts/TTF/DejaVuSansMono.ttf: DejaVu Sans Mono:style=Book
/usr/share/fonts/TTF/DejaVuSansMono-Oblique.ttf: DejaVu Sans Mono:style=Oblique
/usr/share/fonts/TTF/DejaVuSansMono-Bold.ttf: DejaVu Sans Mono:style=Bold
/usr/share/fonts/TTF/DejaVuSansMono-BoldOblique.ttf: DejaVu Sans Mono:style=Bold Oblique
从上述信息可以看出并没有一个叫做DejaVuSansMonoBook.ttf的字体, Book 只是DejaVu Sans Mono的一种style.
使用下述方式即可将默认字体设置为DejaVu Sans Mono Book:
#+BEGIN_SRC emacs-lisp
(custom-set-faces
 '(default ((t (:family "DejaVu Sans Mono" :foundry "Book" :slant normal :weight normal :height 113 :width normal)))))
#+END_SRC

* 编程
** 阅读代码
   
   http://www.caole.net/diary/emacs_write_cpp.html#sec-6
   在 emacs 下读代码通常有三种工具, 最简单的是 etags, 最复杂的是 ecb（emacs code browser）, 位于中间的是 cscope。

*** etags   
   etags 和 ctags 一样, 只不过前者是用于 emacs 的, 后者是用于 vi 的。
   我个人觉得 etags 功能稍稍显得不够用一点, 当然, 也可能是我用的不好:)。
   使用 tags 之前要先对源代码分析建立 tags 文件, 在代码所在目录中运行： etags -R 即可。
   
   我常用的就这几个命令和快捷键：
   
   M-x visit-tags-table <RET> FILE <RET>   选择tags文件
   M-. [TAG] <RET>                         访问标签
   M-*                                     返回
   C-u M-.                                 寻找标签的下一个定义

*** ecb
    使用 M-x ecb-active 激活 ECB, 或者打开一个源码文件, 选择 tools-->Start Code Browser(ECB)
成功激活后Emacs窗口会被切成左右两半。左边的几个窗口依次显示：
    1. 目录,
    2. 当前目录下的文件,
    3. 当前文件中的函数/全局变量等定义,
    4. 文件浏览历史。
    如果打开了一个源文件后函数定义窗口里面是空的, 有可能是因为这个项目过大cedet尚未完成对它的分析,
闲置一段时间后就能看到文件里的定义。
    快捷键：
    C-c . g d    切换到目录窗口
    C-c . g m    切换到函数/方法窗口
    C-c . g s    切换到文件窗口
    C-c . g h    切换到历史窗口
    C-c . g l    切换到上一个编辑窗口
    C-c . h      更详细的帮助信息

**** 代码折叠(code folding)
hs-minor-mode
C-c @ C-M-h : (hs-hide-all) 全部折叠
C-c @ C-M-s : (hs-show-all) 全部展开
C-c @ C-c   : (hs-toggle-hiding)
              (hs-hide-block)/(hs-show-block) 代码块折叠/展开

** 使用 GDB debug
   M-x gdb [填写要进行debug的二进制文件] 启动 gdb
   M-x gdb-many-windows  多窗口显示
   详细参见:
   http://emacser.com/emacs-gdb.htm
   http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html
** 缩进(Tab vs. Space)
默认情况下emacs是使用TAB的，下面的配置语句可设定所有遇到TAB的地方都使用适当个数的空格缩进（写到配置文件~/.emacs中）：
(setq-default indent-tabs-mode  nil)
M-x tabify   将所有超过两个的连接空格使用TAB替换掉。
M-x untabify 将所有TAB使用适当个数的空格替换掉。
http://blog.chinaunix.net/uid-22002972-id-1805467.html
** 清理代码中的不必要的空格和TAB
如果代码文件最后面，或者行尾有很多的不必要的空格, 可以使用 whitespace-mode 看一下当前buffer中有哪些“垃圾”。
如果要清理, 简单的使用 whitespace-cleanup 就可以了。
http://blog.chinaunix.net/uid-22002972-id-1805467.html
** 使用 imenu 命令跳转到当前文件中的函数
M-x imenu RET functionName RET
http://blog.chinaunix.net/uid-22002972-id-1805467.html
** 替换^M
*** 简介
Unix 使用一个新行（^J）字符标记一行的末尾
Windows 使用一个回车加一个新行（^M^J）字符标志每行的末尾
代码在 Windows 的编辑器里编辑并保存过, 就有可能出现 ^M

*** 替换方法
**** 方法(1)
M-x replace-string RET C-q C-m RET RET
**** 方法(2)
使用 dos2unix 工具对文件进行转换, 但是一次转换只能消除每行末尾的一个  符号,
如果一行中有多个  符号, 多次进行转换即可.

** FlyCheck
*** c++11 support
Flycheck provides the option flycheck-gcc-language-standard for this purpose. 

You should not set it globally, because that will break checking of C files, 

but you can set it from c++-mode-hook with the following code in your init file:

(add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++11")))

However, I would recommend against this. Instead, use Directory Variables to 

configure the language standard per project.

Open the root directory of your project in Dired with C-x d, and then type 

M-x add-dir-local-variable RET c++-mode RET flycheck-gcc-language-standard RET "c++11". 

This will create a .dir-locals.el file in the root directory of your project. 

Emacs reads this file whenever you visit a file from this directory or any subdirectory, 

and sets variables according to the rules in this file. Specifically, Emacs will now 

set the language standard for Flycheck syntax checking to C++ 11 for all C++ files in 

your project.

* Emacs Elpa 包管理
** 查看可用的包(插件)
M-x package-list-packages
or 
M-x list-packages

** 安装
在包列表下, 按下 i 会将光标所在的那行对应的软件包标记（最左边出现字符 I）,
按下 x 执行安装操作

取消标记按 u

** 升级
在包列表中, 按下 U 包管理器会自动更新列表, 然后标记可用的更新,
按下 x 执行安装操作

* Tips
** 输入特殊字符
*** 使用 TeX 输入方法
M-x set-input-method TeX
\alpha = α
\beta  = β
\theta = θ
** 替换的时候输入换行符
C-q C-j 可以插入换行符
** 在minibuffer实时显示所按快捷键
https://emacs.stackexchange.com/questions/29216/how-to-get-keystrokes-displayed-in-the-echo-area-immediately
C-h v echo-keystrokes
customize it, with value = 0.1 for example

(setq echo-keystrokes .1)
